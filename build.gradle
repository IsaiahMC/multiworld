import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency

plugins {
	id "dev.architectury.loom" version "1.13-SNAPSHOT" apply false
}

configurations.all {
    resolutionStrategy {
        // Check for updates every build
        cacheChangingModulesFor(0, "seconds")
    }
}

ext.createPreprocessor = { Project proj ->

    def version = proj.hasProperty("targetVersion") ? proj.targetVersion : "mc1201"
    def preprocessDir = proj.layout.buildDirectory.dir("preprocessed")

	// def excluded = proj.hasProperty("excludeFiles") ? proj.excludedFiles : []

    proj.tasks.register("preprocess") {
        // def inputDir = proj.file("src/main/java")
        def inputDir = proj.file(proj.ext.inputSourceDir ?: "src/main/java")
        def excluded = proj.hasProperty("excludedFiles") ? proj.ext.excludedFiles : []
		def outputDir = preprocessDir.get().asFile

        inputs.dir(inputDir)
        outputs.dir(outputDir)

        doLast {
            outputDir.deleteDir()
            outputDir.mkdirs()

            inputDir.eachFileRecurse { file ->
                if (file.isFile() && file.name.endsWith(".java")) {
				
					def fname = proj.relativePath(file).replace(proj.relativePath(inputDir), inputDir.name).replace(File.separatorChar, '/' as char)
					// println(fname);
					// println(excluded);
					
					if (excluded.contains(fname)) {
						println("Skipping from preprocessor: " + fname);
						return // skip this file entirely
					}
				
                    def lines = file.readLines()
                    def out = new StringBuilder()

                    boolean include = true
                    boolean inBlock = false
					boolean branchTaken = false

                    lines.each { line ->
                        def trimmed = line.trim()

						/*
                        if (trimmed.startsWith("// #if")) {
                            inBlock = true
                            include = trimmed.contains(version)
							branchTaken = include
                        } else if (trimmed.startsWith("// #elif")) {
                            if (inBlock) include = trimmed.contains(version)
                        } else if (trimmed.startsWith("// #else")) {
                            if (inBlock) include = true
                        } else if (trimmed.startsWith("// #endif")) {
                            inBlock = false
                            include = true
                        } else {
                            if (include) out.append(line).append("\n")
                        }
						*/
						
						if (trimmed.startsWith("// #if")) {
							inBlock = true
							branchTaken = trimmed.contains(version)
							include = branchTaken
						} else if (trimmed.startsWith("// #elif")) {
							if (inBlock && !branchTaken) {
								branchTaken = trimmed.contains(version)
								include = branchTaken
							} else {
								include = false
							}
						} else if (trimmed.startsWith("// #else")) {
							if (inBlock && !branchTaken) {
								include = true
								branchTaken = true
							} else {
								include = false
							}
						} else if (trimmed.startsWith("// #endif")) {
							inBlock = false
							include = true
							branchTaken = false
						}

						if (include) {
						
							if (branchTaken) {
							
								def cleaned = line
								// Uncomment normal commented-out code
								def t = cleaned.trim()
								if (t.startsWith("//") && !t.startsWith("// #")) {
									cleaned = cleaned.replaceFirst("//\\s?", "") 
								}
								out.append(cleaned).append("\n")
							
							} else {
								out.append(line).append("\n")
							}
						}
                    }

                    // def outFile = new File(outputDir, file.relativeTo(inputDir).path)
                    
					def relative = proj.relativePath(file).replace(proj.relativePath(inputDir), "")
					def outFile = new File(outputDir, relative)

					
					outFile.parentFile.mkdirs()
                    outFile.text = out.toString()
                }
            }
        }
    }

    proj.sourceSets.main.java.srcDirs = [ preprocessDir.get().asFile ]
    proj.tasks.compileJava.dependsOn proj.tasks.preprocess
} as groovy.lang.Closure<org.gradle.api.Project>
 




subprojects {

	configurations.all {
		// Check for updates every build
		resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
	}


	ext {
		mod_version = project.mod_version
		set("mod_version", project.mod_version)
	}

	project.afterEvaluate {
		processResources {
			inputs.property("modVersion",  project.mod_version)
			duplicatesStrategy = DuplicatesStrategy.INCLUDE
			filesMatching("fabric.mod.json") {
				expand "version": project.mod_version
			}
		}
		
	}


	repositories {
	  maven { url = 'https://maven.nucleoid.xyz/' }
	  maven { url = 'https://cursemaven.com/' }
	  maven { url = 'https://oss.sonatype.org/content/repositories/snapshots' }
	  maven { url = "https://pisaiah.github.io/maven-repo/" }
	  maven { url = "https://maven.fabricmc.net/" }
	  maven { url = "https://maven.neoforged.net/releases/" }
	  maven { url = "https://repo.codemc.io/repository/maven-releases/" }
	}

    plugins.withId('java-library', { _ ->
        sourceSets {
            main {
                java {
                    srcDir("src/main/java")
                    
					if (project.version != "1.21.11") {
						srcDir("${rootProject.projectDir}/Multiworld-Common/src/main/java")
					} else {
						srcDir("${rootProject.projectDir}/Multiworld-Common/src/main/java").exclude("me/isaiah/multiworld/command/GameruleCommand.java")
					}
                }
                resources {
                    //srcDir("src/main/resources")
                    srcDir("${rootProject.projectDir}/Multiworld-Common/src/main/resources")
                }
            }
        }
    })
	
	tasks.withType(JavaCompile) {
		options.compilerArgs << "-Xlint:-unchecked"
		options.compilerArgs << "-Xlint:-deprecation"
		options.compilerArgs << "-Xlint:-varargs"
	}
}